编译器分为 前端、中端和后端

前端主要负责：预处理、词法分析、语法分析、语义分析，生成 IR

中端：对 IR 进行分析和优化，例如常量析叠，死代码消除、函数内联。

后端：生成目标代码，把 IR 转化成平台相关的汇编代码，最终由汇编器编译为机器码。

wsam 是 web 的汇编

从高级语言编译器的角度来看，wasm是目标代码，但从浏览器的角度，wasm 更像是 IR, 最终会被 aot/jit 编译器编译成平台相关的机器码。

wsam 最终采用了虚拟机/字节码技术






# wsam 二进制格式

topic: 编写模块二进制格式解码器，实现简化版的 wasm-objdump 工具

模块：wasm 编译，传输和加载的单位；编译后的 wasm 模块主要以二进制格式呈现。

wasm 二进制格式总体结构：
以 magic number 和版本号开头。
在魔数和版本号之后是模块主体内容，被放在不同的段中；wasm 规范共定义了12种段，并给每种段分配了 ID。
除了自定义段，其他所有段最多只出现一次，且必须按照段 ID 递增出现。

# 指令集
Wasm指令包含两部分信息：操作码（Opcode）和操作数（Operands）。
操作码是指令的ID，决定指令将执行的操作；操作数则相当于指令的参数，决定指令的执行结果。

基于栈和基于寄存器的指令集架构各有优缺点，具体如下所示。❏ 基于栈的指令集架构的优点是移植性更好、指令更短、实现简单，但是不能随机访问堆栈中的元素，完成相同功能所需的指令数一般比寄存器架构多，需要频繁地入栈出栈，不利于代码优化。❏ 基于寄存器的指令集架构的优点是速度快，可以充分利用寄存器，有利于程序做运行速度优化，但操作数需要显式指定，指令较长。

## 操作码
wasm 指令的操作码固定为一个字节，因此指令集最多只能包含 256 条指令。
因此称之为字节码。

## 操作数
分为：静态操作数和动态操作数。
静态操作数：直接编码在指令里，跟在操作码的后面。也称立即数。
动态操作数：运行时从操作数栈获取。

## 操作数栈
wasm 使用栈氏虚拟机，带有一个操作数栈。
支持四种基本类型： 32位、64位 整数/浮点数

基于栈和基于寄存器的指令集架构各有优缺点，具体如下所示

❏ 基于栈的指令集架构的优点是移植性更好、指令更短、实现简单，但是不能随机访问堆栈中的元素，完成相同功能所需的指令数一般比寄存器架构多，需要频繁地入栈出栈，不利于代码优化。
❏ 基于寄存器的指令集架构的优点是速度快，可以充分利用寄存器，有利于程序做运行速度优化，但操作数需要显式指定，指令较长。

## 虚拟机
指令循环
指令分派：控制指令、参数指令、变量指令、内存指令、数值指令

## 内存
wasm 内存是一个随机存取存储器（RAM），从本质上讲，它是一个线性的字节数组，可以按偏移量读写。
数值在 wasm 内存中按小端方式存储。

wasm 内存是无类型的，没办法在编译器对它做任何类型检查。
wasm 内存可以在限制范围内动态增长，增长必须以页为单位，一页是64kb
一个 wasm 能够使用的内存最多 4GB

## 函数调用
内部函数：
外部函数：普通函数 和 本地函数 

## 控制指令
顺序、循环、分支
block\loop\if


# AOT编译器
字节码程序有三种执行方式：解释执行、预先编译为本地可执行程序、运行时即时编译为本地机器代码。
其中预先编译方式称为 aot

为了在快速启动和高度优化之间取得平衡，很多 jit/aot 实现使用了分层编译技术。
分层编译分为两层：第一层：编译器可以较快的生成本地代码并执行；
第二层：编译器在后台线程中，生成执行效果更好的代码，并替换 tier 生成的代码。


